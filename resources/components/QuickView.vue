<template>
	<!-- eslint-disable vue/no-v-html -->
	<div
		class="sdms-quick-view"
		:class="rootClasses"
		@keyup.esc="close"
		@keyup.left="$emit( 'previous', true )"
		@keyup.right="$emit( 'next', true )"
	>
		<header ref="header" class="sdms-quick-view__header">
			<div
				v-if="isImage"
				class="sdms-quick-view__thumbnail-wrapper"
				:style="thumbnailWrapperStyle"
			>
				<spinner
					v-if="thumbnailWrapperStyle && showSpinner"
					class="sdms-quick-view__spinner"
				></spinner>
				<img
					:srcset="srcset"
					:sizes="sizes"
					:src="thumbnail"
					:alt="title"
					class="sdms-quick-view__thumbnail"
					:class="imageClasses"
					@load="onThumbnailLoad"
				>
			</div>

			<sd-player
				v-else-if="isVideo || isAudio"
				:options="playerOptions"
				:fallback-url="videoinfo[ 0 ].url"
				@play.once="onPlay"
			></sd-player>

			<button
				ref="close"
				class="sdms-quick-view__button sdms-quick-view__close-button"
				:title="closeButtonText"
				@click="close"
			>
				<cdx-icon :icon="cdxIconClose"></cdx-icon>
				<span class="sdms-quick-view__button__text">
					{{ closeButtonText }}
				</span>
			</button>

			<div class="sdms-quick-view__controls">
				<button
					ref="previous"
					class="sdms-quick-view__button"
					:title="previousButtonText"
					@keyup.enter="$emit( 'previous', true )"
					@click="$emit( 'previous' )"
				>
					<cdx-icon :icon="cdxIconPrevious"></cdx-icon>
					<span class="sdms-quick-view__button__text">
						{{ previousButtonText }}
					</span>
				</button>

				<button
					ref="next"
					class="sdms-quick-view__button"
					:title="nextButtonText"
					@keyup.enter="$emit( 'next', true )"
					@click="$emit( 'next' )"
				>
					<cdx-icon :icon="cdxIconNext"></cdx-icon>
					<span class="sdms-quick-view__button__text">
						{{ nextButtonText }}
					</span>
				</button>
			</div>
		</header>

		<!-- File details: most of this information comes from the Commons
		Metadata API; the data available for a given file can vary widely and
		may include complex HTML generated by templates. -->
		<div class="sdms-quick-view__body">
			<h3 v-if="displayName" class="sdms-quick-view__title">
				<a
					ref="title"
					:href="canonicalurl"
					:title="title">
					{{ displayName }}
				</a>
			</h3>

			<p v-if="description" class="sdms-quick-view__description">
				<bdi v-html="description"></bdi>
			</p>

			<p
				v-if="artist"
				class="sdms-quick-view__list-item sdms-quick-view__list-item--user sdms-quick-view__artist"
			>
				<cdx-icon :icon="cdxIconUserAvatar"></cdx-icon>
				<bdi><span v-html="artist"></span></bdi>
			</p>

			<!-- Attempt to show license text, an appropriate icon, and an
			optional link to external license URL -->
			<p v-if="licenseText" class="sdms-quick-view__list-item sdms-quick-view__license">
				<cdx-icon v-if="licenseIcon" :icon="licenseIcon"></cdx-icon>
				<a
					v-if="licenseUrl"
					:href="licenseUrl"
					target="_blank">
					<span v-html="licenseText"></span>
				</a>
				<span v-else v-html="licenseText"></span>
			</p>

			<p v-if="assessmentList" class="sdms-quick-view__list-item sdms-quick-view__assessment">
				<cdx-icon :icon="cdxIconUnStar"></cdx-icon>
				<span>{{ assessmentList }}</span>
			</p>

			<p v-if="displayName" class="sdms-quick-view__list-item sdms-quick-view__copy-full-name">
				<cdx-icon :icon="filenameIcon"></cdx-icon>
				<sd-copy-text-layout
					:copy-text="displayName"
					:inline="true"
					@copy="handleFilenameCopy"
				></sd-copy-text-layout>
			</p>

			<p
				v-if="displayNameWithoutExtension"
				class="sdms-quick-view__list-item sdms-quick-view__copy-name-no-extension"
			>
				<cdx-icon :icon="cdxIconWikiText"></cdx-icon>
				<sd-copy-text-layout
					:copy-text="'[[' + title + '|' + displayNameWithoutExtension + ']]'"
					:inline="true"
					:hide-overflow="true"
					@copy="handleWikitextCopy"
				></sd-copy-text-layout>
			</p>

			<!-- Sometimes this is free text, sometimes it is formatted. Can
			we make things semi-consistent? -->
			<p v-if="creationDate" class="sdms-quick-view__list-item sdms-quick-view__creation-date">
				<cdx-icon :icon="cdxIconClock"></cdx-icon>
				<span v-html="creationDate"></span>
			</p>

			<p v-if="resolution" class="sdms-quick-view__list-item sdms-quick-view__resolution">
				<cdx-icon :icon="cdxIconCamera"></cdx-icon>
				<!-- Resolution should never flip. -->
				<span dir="ltr">{{ resolution }}</span>
			</p>

			<p v-if="mimeType" class="sdms-quick-view__list-item  sdms-quick-view__mine-type">
				<cdx-icon :icon="cdxIconPageSettings"></cdx-icon>
				<span>{{ mimeType }}</span>
			</p>

			<a
				:href="canonicalurl"
				:title="title"
				class="sdms-quick-view__cta"
				@click="onMoreDetailsClick"
			>
				{{ $i18n( 'mediasearch-quickview-button-text' ).text() }}
			</a>
		</div>
	</div>
</template>

<script>
const SdPlayer = require( './base/Player.vue' ),
	SdCopyTextLayout = require( './base/CopyTextLayout.vue' ),
	Spinner = require( './Spinner.vue' ),
	userLangCode = mw.config.get( 'wgUserLanguage' ),
	PREVIEW_SIZES = [ 640, 800, 1200, 1600 ], // Pre-defined set of thumbnail image width values
	MAX_SIZE = 2000,
	assessmentLabels = mw.config.get( 'sdmsAssessmentQuickviewLabels' );

const { CdxIcon } = require( '@wikimedia/codex' );

const {
	cdxIconCamera,
	cdxIconClock,
	cdxIconClose,
	cdxIconImageLayoutFrameless,
	cdxIconLogoCC,
	cdxIconNext,
	cdxIconPageSettings,
	cdxIconPlay,
	cdxIconPrevious,
	cdxIconReference,
	cdxIconUnLock,
	cdxIconUserAvatar,
	cdxIconUnStar,
	cdxIconWikiText,
	cdxIconVolumeUp
} = require( './icons.json' );

/**
 * @file QuickView.vue
 *
 * Component to display expanded details about a given search result
 *
 * v-html use: all instances of v-html output trusted API/parser content.
 */
// @vue/component
module.exports = exports = {
	name: 'QuickView',

	components: {
		CdxIcon,
		'sd-player': SdPlayer,
		'sd-copy-text-layout': SdCopyTextLayout,
		spinner: Spinner
	},

	inheritAttrs: false,

	props: {
		title: {
			type: String,
			required: true
		},

		canonicalurl: {
			type: String,
			required: true
		},

		imageinfo: {
			type: Array,
			required: false,
			default: function () {
				return [ {} ];
			}
		},

		videoinfo: {
			type: Array,
			required: false,
			default: function () {
				return [ {} ];
			}
		},

		mediaType: {
			type: String,
			required: false,
			default: 'image'
		},

		isDialog: {
			type: Boolean
		}
	},

	emits: [
		'previous',
		'next',
		'close'
	],

	data: function () {
		return {
			cdxIconCamera,
			cdxIconClock,
			cdxIconClose,
			cdxIconNext,
			cdxIconPageSettings,
			cdxIconPrevious,
			cdxIconUserAvatar,
			cdxIconWikiText,
			cdxIconUnStar,
			thumbnailWrapperStyle: false,
			isExtraSmall: false,
			showSpinner: false,
			closeButtonText: this.$i18n( 'mediasearch-quickview-close-button-text' ).text(),
			previousButtonText: this.$i18n( 'mediasearch-quickview-previous-button-text' ).text(),
			nextButtonText: this.$i18n( 'mediasearch-quickview-next-button-text' ).text()
		};
	},

	computed: {
		rootClasses: function () {
			return {
				'sdms-quick-view--image': this.isImage,
				'sdms-quick-view--audio': this.isAudio,
				'sdms-quick-view--video': this.isVideo,
				'sdms-quick-view--dialog': this.isDialog
			};
		},

		imageClasses: function () {
			return {
				'sdms-quick-view__thumbnail--loaded': !this.thumbnailWrapperStyle,
				'sdms-quick-view__thumbnail--xsmall': this.isExtraSmall
			};
		},

		isImage: function () {
			return this.mediaType === 'image';
		},

		isVideo: function () {
			return this.mediaType === 'video';
		},

		isAudio: function () {
			return this.mediaType === 'audio';
		},

		/**
		 * @return {string|undefined}
		 */
		thumbnail: function () {
			return this.imageinfo[ 0 ].thumburl;
		},

		/**
		 * Progressively larger thumbnail images, generated with mw.util.parseImageUrl
		 * https://doc.wikimedia.org/mediawiki-core/master/js/#!/api/mw.util-method-parseImageUrl
		 *
		 * @return {string|boolean}
		 */
		srcset: function () {
			let attributeString = '';

			// If the URL produced by parseImageUrl isn't a thumbnail, we won't
			// be able to use resizeUrl and should just omit the srcset.
			if ( typeof mw.util.parseImageUrl( this.thumbnail ).resizeUrl !== 'function' ) {
				return false;
			}

			if ( this.isDialog ) {
				// For Dialog-mode quickview, the image can theoretically become
				// any size (some users enable mobile skin even when using large
				// desktop monitors). So we should generate a series of image
				// URLs to attempt to accommodate most sizes and concatenate a
				// string to use as the attribute value.
				PREVIEW_SIZES.forEach(
					( size ) => {
						const url = mw.util.parseImageUrl( this.thumbnail ).resizeUrl( size );
						attributeString += url + ' ' + size + 'w,\n';
					}
				);

				// Add one final item to the list representing the maximum size.
				// If the underlying image file is smaller than the requested size,
				// parseImageUrl will simply return a link to the full-size image.
				attributeString +=
					mw.util.parseImageUrl( this.thumbnail ).resizeUrl( MAX_SIZE ) +
					' ' +
					MAX_SIZE +
					'w';
			} else {
				// For non-dialog quickview, the element will remain confined to
				// a sidebar and will rarely be wider ~640px (would require a
				// massive screen)
				attributeString +=
					mw.util.parseImageUrl( this.thumbnail ).resizeUrl( PREVIEW_SIZES[ 0 ] ) +
					' ' +
					PREVIEW_SIZES[ 0 ] +
					'w';
			}

			return attributeString;
		},

		/**
		 * @return {string}
		 */
		sizes: function () {
			let attributeString = '';

			if ( this.isDialog ) {
				// For dialog mode, use an image size that matches the width of
				// the viewport since the Quickview is full-width
				PREVIEW_SIZES.forEach( ( size ) => {
					attributeString += '(min-width: ' + size + 'px) ' + size + 'px,\n';
				} );
				attributeString += MAX_SIZE + 'px';
			} else {
				// For non-dialog mode, the first preview size is all that is
				// necessary
				attributeString += PREVIEW_SIZES[ 0 ] + 'px';
			}

			return attributeString;
		},

		/**
		 * @return {Object|undefined}
		 */
		metadata: function () {
			// If we are dealing with an audio or video file, metadata will live
			// in a videoinfo prop instead of an imageinfo prop. Contents will
			// be mostly the same.
			if ( this.isAudio || this.isVideo ) {
				return this.videoinfo[ 0 ].extmetadata;
			} else {
				return this.imageinfo[ 0 ].extmetadata;
			}
		},

		/**
		 * @return {string|null}
		 */
		displayName: function () {
			const title = mw.Title.newFromText( this.title );
			return title ? title.getMainText() : null;
		},

		/**
		 * @return {string|null}
		 */
		displayNameWithoutExtension: function () {
			const title = mw.Title.newFromText( this.title );
			return title ? title.getName() : null;
		},

		filenameIcon: function () {
			switch ( this.mediaType ) {
				case 'audio':
					return cdxIconVolumeUp;
				case 'video':
					return cdxIconPlay;
				default:
					return cdxIconImageLayoutFrameless;
			}
		},

		/**
		 * @return {string|null} String that may contain HTML
		 */
		description: function () {
			if ( this.metadata && this.metadata.ImageDescription ) {
				return this.metadata.ImageDescription.value;
			} else {
				return null;
			}
		},

		/**
		 * @return {string|null} String that may contain HTML (often a link to a User page)
		 */
		artist: function () {
			if ( this.metadata && this.metadata.Artist ) {
				return this.metadata.Artist.value;
			} else {
				return null;
			}
		},

		/**
		 * @return {string|null}
		 */
		licenseText: function () {
			if ( this.metadata && this.metadata.UsageTerms ) {
				return this.metadata.UsageTerms.value;
			} else if ( this.metadata && this.metadata.LicenseShortName ) {
				return this.metadata.LicenseShortName.value;
			} else {
				return null;
			}
		},

		licenseIcon: function () {
			if ( this.metadata && this.metadata.License ) {
				return this.getLicenseIcon( this.metadata.License.value );
			} else if ( this.metadata && this.metadata.LicenseShortName ) {
				return this.getLicenseIcon( this.metadata.LicenseShortName.value );
			} else {
				return null;
			}
		},

		licenseUrl: function () {
			if ( this.metadata && this.metadata.LicenseUrl ) {
				return this.metadata.LicenseUrl.value;
			} else {
				return null;
			}
		},

		/**
		 * If the image contains Assessment metadata, and if user-facing labels
		 * for those assesment values has been configured, show a human-readible
		 * label for each assessment associated wiht the file.
		 *
		 * @return {string|null}
		 */
		assessmentList: function () {
			const assessmentList = [];

			// If assessemnt labels have been enabled and if the image contains
			// assessment metadata
			if (
				assessmentLabels && // this data comes from  a JS config var
				this.metadata &&
				this.metadata.Assessments &&
				this.metadata.Assessments.value
			) {
				const assessmentValues = this.metadata.Assessments.value.split( '|' );
				assessmentValues.forEach( ( assessment ) => {
					// Messages that can be used here:
					// * mediasearch-filter-assessment-valued-image
					// * mediasearch-filter-assessment-quality-image
					// * mediasearch-filter-assessment-featured-image
					// * mediasearch-filter-assessment-picture-of-the-day
					// * mediasearch-filter-assessment-picture-of-the-year
					assessmentList.push( this.$i18n( assessmentLabels[ assessment ] ).text() );
				} );
				return assessmentList.join( this.$i18n( 'comma-separator' ).text() );
			} else {
				return null;
			}
		},

		/**
		 * @return {string|null} String that may contain HTML
		 */
		creationDate: function () {
			const dateString = this.metadata &&
					this.metadata.DateTimeOriginal &&
					this.metadata.DateTimeOriginal.value || null,
				// eslint-disable-next-line security/detect-unsafe-regex
				dateRegex = /^([0-9]{2,4})(-[0-9]{2})?(-[0-9]{2})?/,
				dateRegexResult = dateRegex.exec( dateString ),
				dateObject = new Date( dateRegex.test( dateString ) ?
					dateRegexResult[ 0 ] : undefined );

			// If we have a value for DateTimeOriginal at all, create a date
			// object using that value and test for validity (JS unhelpfully
			// doesn't throw an error in the Date constructor if invalid).
			//
			// If we are dealing with a date value that we can't parse, just
			// return whatever the original string was in the hope that it will
			// make sense to the user. In most cases, it should: for example,
			// we're already getting back a translated string if a common phrase
			// like "circa" is used.
			if ( !( dateObject instanceof Date ) || isNaN( dateObject.getTime() ) ) {
				return dateString;
			}

			try {
				// Format the date in the user's language. Passing undefined as the
				// first arg to toLocaleDateString() will cause it to default to the
				// browser language, but we should keep this consistent with the UI
				// language.
				return dateObject.toLocaleDateString(
					mw.config.get( 'wgUserLanguage' ),
					{
						timeZone: 'UTC',
						year: 'numeric',
						// only display month & day if they were found to be present in date
						month: dateRegexResult[ 2 ] !== undefined ? 'long' : undefined,
						day: dateRegexResult[ 3 ] !== undefined ? 'numeric' : undefined
					}
				);
			} catch ( e ) {
				if ( e.message === 'Unsupported time zone specified UTC' ) {
					// Special-case a very specific kind of error where,
					// I suspect, some highly specific browser build is
					// unable to parse UTC timezones
					// I've not been able to reproduce this with any input,
					// errors are sparse, and always of the same browser:
					// (Samsung Browser 2.0 on Tizen Linux), probably also
					// of the same user
					// @see https://phabricator.wikimedia.org/T283870
					return null;
				}

				throw e;
			}
		},

		/**
		 * @return {string|null}
		 */
		resolution: function () {
			const width = this.imageinfo ? this.imageinfo[ 0 ].width : null,
				height = this.imageinfo ? this.imageinfo[ 0 ].height : null;

			if ( width && height ) {
				return width.toLocaleString( userLangCode ) + ' × ' + height.toLocaleString( userLangCode );
			} else {
				return null;
			}
		},

		mimeType: function () {
			return this.imageinfo[ 0 ].mime;
		},

		playerOptions: function () {
			if ( this.isVideo || this.isAudio ) {
				return {
					autoplay: false,
					controls: true,
					fluid: true,
					poster: this.videoinfo[ 0 ].thumburl,
					sources: this.videoinfo[ 0 ].derivatives
				};
			} else {
				return {};
			}
		}
	},

	methods: {
		/**
		 * Emit a close event. If the user triggered this from the keyboard instead
		 * of by clicking, add an additional parameter so that the parent knows to
		 * restore focus to the originating search result.
		 *
		 * @param {Event} event
		 * @fires close
		 */
		close: function ( event ) {
			// If triggered by the keyboard, restore focus to previous element
			if ( event.detail === 0 ) {
				this.$emit( 'close', true );
			} else {
				this.$emit( 'close' );
			}
		},

		getLicenseIcon: function ( valueString ) {
			if ( /^cc|attribution/i.test( valueString ) ) {
				return cdxIconLogoCC;
			} else if ( /^pd|no restrictions/i.test( valueString ) ) {
				return cdxIconUnLock;
			} else {
				return cdxIconReference;
			}
		},

		/**
		 * Programatically set focus on the title element; used by the parent
		 * component when the Quickview is opened.
		 *
		 * @param {string|null} focusOn Which ref to focus on when opened
		 */
		// eslint-disable-next-line vue/no-unused-properties
		focus: function ( focusOn ) {
			if ( focusOn ) {
				this.$refs[ focusOn ].focus();
			}
		},

		/**
		 * Set the height of the div wrapping the thumbnail image to the display
		 * height of that image to avoid a layout jump when the image loads.
		 */
		getThumbnailWrapperStyle: function () {
			if ( !this.imageinfo ) {
				return;
			}

			const imgWidth = this.imageinfo[ 0 ].width;
			const imgHeight = this.imageinfo[ 0 ].height;
			const elWidth = this.$refs.header.offsetWidth;
			let height;
			if ( imgWidth >= imgHeight ) {
				// For landscape-oriented images, calculate the height
				// based on the aspect ratio and the width of the container.
				// Use this, unless the natural height of the original file is
				// smaller.
				height = Math.min(
					( imgHeight * elWidth ) / imgWidth,
					imgHeight
				);
			} else {
				// A portrait-oriented image could be limited by several
				// constraints: the natural image height (e.g. an original file
				// that's only 200px tall), the CSS-enforced max-height of the
				// image (60vh), or the max-width of the container.
				height = Math.min(
					imgHeight,
					window.innerHeight * 0.6,
					( imgHeight * elWidth ) / imgWidth
				);
			}

			// For very short images, we need to add some vertical padding so
			// that the content below the image doesn't crowd the absolutely-
			// positioned controls.
			if ( height < 100 ) {
				height += 30;
				// We'll use this to add a class to the image to add 15px of
				// top and bottom padding.
				this.isExtraSmall = true;
			}

			this.thumbnailWrapperStyle = {
				height: height + 'px',
				width: '100%'
			};
		},

		/**
		 * Once the thumbnail has loaded, we no longer need the spinner, and we
		 * need to remove the hard-coded height of the wrapper element in case
		 * the user adjusts the viewport size.
		 */
		onThumbnailLoad: function () {
			this.thumbnailWrapperStyle = false;
		},

		onMoreDetailsClick: function () {
			// T297400 updated from ID to Title for new schema
			/* eslint-disable camelcase */
			this.$log( {
				action: 'quickview_more_details_click',
				search_result_page_title: this.title
			} );
			/* eslint-enable camelcase */
		},

		onPlay: function () {
			/* eslint-disable camelcase */
			this.$log( {
				action: 'quickview_media_play',
				search_media_type: this.mediaType
			} );
			/* eslint-enable camelcase */
		},

		/**
		 * Log when the user copies the name of the active file using the
		 * built-in tool
		 */
		handleFilenameCopy: function () {
			this.$log( { action: 'quickview_filename_copy' } );
		},

		/**
		 * Log when the user copies the wikitext link of the active file using
		 * the built-in tool
		 */
		handleWikitextCopy: function () {
			this.$log( { action: 'quickview_wikitext_link_copy' } );
		}
	},

	mounted: function () {
		this.getThumbnailWrapperStyle();

		setTimeout( () => {
			this.showSpinner = true;
		}, 500 );
	}
};
</script>
